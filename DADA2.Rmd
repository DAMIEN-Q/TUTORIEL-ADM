---
title: "R Notebook"
output: github_document
---
    Installation du package "DADA2"

```{r, cache=TRUE}
library(dada2)
```

    Chargement du package de données à traiter

```{r,cache=TRUE}
path <- "~/TUTORIEL-ADM/MiSeq_SOP"
list.files(path)
```

    Création des listes des fichiers Forward (fnFs) et Reverse (fnRs)

```{r, cache=TRUE}
fnFs <- sort # Les met dans l'ordre alphabétique
        (list.files(path, pattern="_R1_001.fastq", # Cherche dans le dossier "path" tous les fichiers qui contiennent "_R1_001.fastq"
                    full.names = TRUE)) # Garde le chemin complet

fnRs <- sort(list.files(path, pattern="_R2_001.fastq", full.names = TRUE))
```

    Nom de chaque échantillon extrait du nom du fichier
  
```{r, cache=TRUE}
sample.names <- sapply(strsplit(basename(fnFs), "_"), `[`, 1)
```

    Visualisation des profils de qualité de lecture 
      Qualité de lecture Forward
  
    

```{r, cache=TRUE}
plotQualityProfile(fnFs[1:2])
```

C’est un diagnostic visuel pour voir la qualité des bases (nucléotides) le long des lectures.

- Le fond gris représente la fréquence de chaque score de qualité à chaque position de la lecture

- La ligne verte correspond à la moyenne du score de qualité à chque position

- La ligne orange correspond au quartiles montrant la variabilité de la qualité

- La ligne rouge signifie la proportion des lectures qui atteignent cette position (Illumina = plate, les lectures ont la même longeur)

--> Ici, bonne qualité de lecture forward

    Qualité de lecture Reverse
    
```{r, cache=TRUE}
plotQualityProfile(fnRs[1:2])
```

Contrairement à la qualité des lectures forward, la qualité des lectures reverse sont beaucoup moindre. On observe une chute brutale de la qualité (en vert) ainsi que sa variation (en orange). Ce phénomène est normal avec Illumina et DADA2 à un algorithme assez robuste pour les séquences de moindre qualité en intégrant des informations de qualité dans son modèle d'erreur.


    Filtrer et Rogner

```{r, cache=TRUE}
filtFs <- file.path(path, "filtered", # Crée un chemin vers un sous-dosier "filtered" à l'intérieur du dossier 'path"
                paste0(sample.names,"_F_filt.fastq.gz")) # Contruit le nom du fichier filtré pour chaque échantillon

filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))

#Attribution des noms des échantillons aux fichiers (fichier filtré lié à son échantillon)
names(filtFs) <- sample.names
names(filtRs) <- sample.names
```

```{r, cache=TRUE} 
# Prend en entrée les fichiers bruts "FASTQ" de forward et reverse, leur applique des filtres de qualité et les sauvegarde dans de nouveaux fichiers

out <- filterAndTrim(fnFs, # Fichier brut Forward
                     filtFs, # Fichier Forward filtré de sortie
                     fnRs, # Fichier brut Reverse
                     filtRs, # Fichier Reverse filtré de sortie
                     truncLen=c(240,160), # Tronque les lectures Forward à 240 bases et Reverse à 160 bases
              maxN=0, # Elimine toute lecture contenant un "N" (base inconnu)
              maxEE=c(2,2), # Max d'erreurs attendues par lecture (2 pour Forward et 2 pour Reverse)
              truncQ=2, # Coupe une lecture dès qu'un score de qualité tombe en dessous de 2
              rm.phix=TRUE, # Supprime les lectures provenant du génome PhiX (contrôle pour Illumina)
              compress=TRUE, # Enregistre les fichiers en ".fastq.gz"
              multithread=FALSE
              )

head(out) # Affiche un tableau résumant le filtrage
```

    Taux d'erreur de séquençage

Les séquenceurs font parfois des erreurs, certaines bases lues ne sont pas les vraies bases
DADA2 permet de distinguer les vraies séquences biologiques des séquences erronées.

--> DADA2 = modèle d'erreur PARAMETRIQUE

```{r, cache=TRUE}
errF <- learnErrors(filtFs, multithread=TRUE) # Apprend un modèle statistique des erreurs à partir des lectures filtrées Forward
```
```{r, cache=TRUE}
errR <- learnErrors(filtRs, multithread=TRUE) # Apprend un modèle statistique des erreurs à partir des lectures filtrées Reverse
```
Visualisation des taux d'erreur

```{r, cache=TRUE}
plotErrors(errF, nominalQ=TRUE)
```

- Les points correspondent aux taux d'erreurs observés
- La ligne noire correspond au taux d'erreur estimé par l'algorithme
- La ligne rouge correspond au taux d'erreur attendu selon le Q score (taux d'erreur théorique selon le Q score).

On observe bien que les points suivent bien la ligne noire et que par conséquent, les taux d'erreurs observés sont partiquement égaux aux taux d'erreur estimé. De plus, on observe bien une diminution du taux d'erreur plus le Q score augmente qui tend à suivre la ligne rouge.

      Application de l'algo de DADA2 

```{r, cache=TRUE}
dadaFs <- dada(filtFs, # Fichiers forward filtrés
               err=errF, # Modèle d'erreurs appris précédemment
               multithread=TRUE # Permet d'utiliser plusieurs coeurs en même temps pour aller plus vite
               )
```

Pour chaque lecture filtrée, l'algorithme va comparer la séquence observée au modèle d'erreurs. Il corrige les lectures en tenant compte des probabilités d'erreurs : 
- Si une différence peut-être expliquée par une erreur de séquençage = Séquence corrigée
- Si une différence est trop grande pour être une simple erreur  = Séquence considérée comme une vraie variante biologique (ASV)

```{r, cache=TRUE}
dadaRs <- dada(filtRs, err=errR, multithread=TRUE)
```

Idem que précédemment mais avec les lectures filtrées de Reverse

      Inspection 

```{r, cache=TRUE}
dadaFs[[1]]
```

Exemple : Pour le 1er échantillon, l'algorithme à identifier 128 vrais variants dans 1979 séquences 

      Fusion des lectures appariées

```{r, cache=TRUE}
# Reconstruction des séquences complètes des amplicons
mergers <- mergePairs(dadaFs, # ASVs du brin forward
                      filtFs, # Fichiers FASTQ filtrés forward
                      dadaRs, # ASVs du brin reverse
                      filtRs, # Fichiers FASTQ filtrés reverse
                      verbose=TRUE # Affiche des détails pendant l'exécution
                      )
head(mergers[[1]])
```

Permet d'observer les vraies séquences les plus abondantes dans l'échantillon. Les colonnes "nmismatch" (nombre de bases différentes dans la zone de chevauchement) et "nindel" (insertion ou délétions observées) permettent de voir si la fusion est cleen.

      Construction d'une table de séquence

```{r, cache=TRUE}
seqtab <- makeSequenceTable(mergers) 
dim(seqtab)
```

Permet de créer une table de séquence qui prend en entrée les séquences fusionnées.

- Lignes : Echantillons

- Colonnes : ASVs

- Valeurs : Abondance des séquences

La commande "dim()" permet de retourner la matrice de longueur 2
Ici, le 1er chiffre correspond au nombre d'échantillon (20) et le 2ème chiffre au nombre d'ASV (293)


      Inspect distribution of sequence lenghs
  
```{r, cache=TRUE}
table(nchar(getSequences(seqtab)))
```

Supprimer les chimères

```{r}
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)
```
```{r}
sum(seqtab.nochim)/sum(seqtab)
```

Track reads through the pipeline

```{r}
getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) <- sample.names
head(track)
```

Assign taxonomy

```{r, cache=TRUE}
taxa <- assignTaxonomy(seqtab.nochim, "~/TUTORIEL-ADM/silva_nr99_v138.2_toGenus_trainset.fa.gz?download=1", multithread=TRUE)
```

Examination 

```{r, cache=TRUE}
taxa.print <- taxa # Removing sequence rownames for display only
rownames(taxa.print) <- NULL
head(taxa.print)
```

Evaluation de la précision

```{r}
unqs.mock <- seqtab.nochim["Mock",]
unqs.mock <- sort(unqs.mock[unqs.mock>0], decreasing=TRUE) # Drop ASVs absent in the Mock
cat("DADA2 inferred", length(unqs.mock), "sample sequences present in the Mock community.\n")
```

```{r}
mock.ref <- getSequences(file.path(path, "HMP_MOCK.v35.fasta"))
match.ref <- sum(sapply(names(unqs.mock), function(x) any(grepl(x, mock.ref))))
cat("Of those,", sum(match.ref), "were exact matches to the expected reference sequences.\n")
```

