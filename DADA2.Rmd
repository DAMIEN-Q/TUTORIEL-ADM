---
title: "R Notebook"
output: github_document
---
    Installation du package "DADA2"

```{r, cache=TRUE}
library(dada2)
```

    Chargement du package de données à traiter

```{r,cache=TRUE}
path <- "~/TUTORIEL-ADM/MiSeq_SOP"
list.files(path)
```

    Création des listes des fichiers Forward (fnFs) et Reverse (fnRs)

```{r, cache=TRUE}
fnFs <- sort # Les met dans l'ordre alphabétique
        (list.files(path, pattern="_R1_001.fastq", # Cherche dans le dossier "path" tous les fichiers qui contiennent "_R1_001.fastq"
                    full.names = TRUE)) # Garde le chemin complet

fnRs <- sort(list.files(path, pattern="_R2_001.fastq", full.names = TRUE))
```

    Nom de chaque échantillon extrait du nom du fichier
  
```{r, cache=TRUE}
sample.names <- sapply(strsplit(basename(fnFs), "_"), `[`, 1)
```

    Visualisation des profils de qualité de lecture 
      Qualité de lecture Forward
  
    

```{r, cache=TRUE}
plotQualityProfile(fnFs[1:2])
```

C’est un diagnostic visuel pour voir la qualité des bases (nucléotides) le long des lectures.

- Le fond gris représente la fréquence de chaque score de qualité à chaque position de la lecture

- La ligne verte correspond à la moyenne du score de qualité à chque position

- La ligne orange correspond au quartiles montrant la variabilité de la qualité

- La ligne rouge signifie la proportion des lectures qui atteignent cette position (Illumina = plate, les lectures ont la même longeur)

--> Ici, bonne qualité de lecture forward

    Qualité de lecture Reverse
    
```{r, cache=TRUE}
plotQualityProfile(fnRs[1:2])
```

Contrairement à la qualité des lectures forward, la qualité des lectures reverse sont beaucoup moindre. On observe une chute brutale de la qualité (en vert) ainsi que sa variation (en orange). Ce phénomène est normal avec Illumina et DADA2 à un algorithme assez robuste pour les séquences de moindre qualité en intégrant des informations de qualité dans son modèle d'erreur.


    Filtrer et Rogner

```{r, cache=TRUE}
filtFs <- file.path(path, "filtered", # Crée un chemin vers un sous-dosier "filtered" à l'intérieur du dossier 'path"
                paste0(sample.names,"_F_filt.fastq.gz")) # Contruit le nom du fichier filtré pour chaque échantillon

filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))

#Attribution des noms des échantillons aux fichiers (fichier filtré lié à son échantillon)
names(filtFs) <- sample.names
names(filtRs) <- sample.names
```

```{r, cache=TRUE} 
# Prend en entrée les fichiers bruts "FASTQ" de forward et reverse, leur applique des filtres de qualité et les sauvegarde dans de nouveaux fichiers

out <- filterAndTrim(fnFs, # Fichier brut Forward
                     filtFs, # Fichier Forward filtré de sortie
                     fnRs, # Fichier brut Reverse
                     filtRs, # Fichier Reverse filtré de sortie
                     truncLen=c(240,160), # Tronque les lectures Forward à 240 bases et Reverse à 160 bases
              maxN=0, # Elimine toute lecture contenant un "N" (base inconnu)
              maxEE=c(2,2), # Max d'erreurs attendues par lecture (2 pour Forward et 2 pour Reverse)
              truncQ=2, # Coupe une lecture dès qu'un score de qualité tombe en dessous de 2
              rm.phix=TRUE, # Supprime les lectures provenant du génome PhiX (contrôle pour Illumina)
              compress=TRUE, # Enregistre les fichiers en ".fastq.gz"
              multithread=FALSE
              )

head(out) # Affiche un tableau résumant le filtrage
```

    Taux d'erreur de séquençage

Les séquenceurs font parfois des erreurs, certaines bases lues ne sont pas les vraies bases
DADA permet de distinguer les vraies séquences biologiques des séquences erronées.

--> DADA2 = modèle d'erreur PARAMETRIQUE

```{r, cache=TRUE}
errF <- learnErrors(filtFs, multithread=TRUE) # Apprend un modèle statistique des erreurs à partir des lectures filtrées Forward
```
```{r, cache=TRUE}
errR <- learnErrors(filtRs, multithread=TRUE)
```
Visualisation des taux d'erreur

```{r, cache=TRUE}
plotErrors(errF, nominalQ=TRUE)
```
Application de l'algo de DADA2 

```{r, cache=TRUE}
dadaFs <- dada(filtFs, err=errF, multithread=TRUE)
```

```{r, cache=TRUE}
dadaRs <- dada(filtRs, err=errR, multithread=TRUE)
```

Inspection 

```{r}
dadaFs[[1]]
```
Fusion des lectures appariées

```{r, cache=TRUE}
mergers <- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=TRUE)
head(mergers[[1]])
```

Construction d'une table de séquence

```{r}
seqtab <- makeSequenceTable(mergers)
dim(seqtab)
```

  Inspect distribution of sequence lenghs
  
```{r}
table(nchar(getSequences(seqtab)))
```

Supprimer les chimères

```{r}
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)
```
```{r}
sum(seqtab.nochim)/sum(seqtab)
```

Track reads through the pipeline

```{r}
getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) <- sample.names
head(track)
```

Assign taxonomy

```{r, cache=TRUE}
taxa <- assignTaxonomy(seqtab.nochim, "~/TUTORIEL-ADM/silva_nr99_v138.2_toGenus_trainset.fa.gz?download=1", multithread=TRUE)
```

Examination 

```{r, cache=TRUE}
taxa.print <- taxa # Removing sequence rownames for display only
rownames(taxa.print) <- NULL
head(taxa.print)
```

Evaluation de la précision

```{r}
unqs.mock <- seqtab.nochim["Mock",]
unqs.mock <- sort(unqs.mock[unqs.mock>0], decreasing=TRUE) # Drop ASVs absent in the Mock
cat("DADA2 inferred", length(unqs.mock), "sample sequences present in the Mock community.\n")
```

```{r}
mock.ref <- getSequences(file.path(path, "HMP_MOCK.v35.fasta"))
match.ref <- sum(sapply(names(unqs.mock), function(x) any(grepl(x, mock.ref))))
cat("Of those,", sum(match.ref), "were exact matches to the expected reference sequences.\n")
```

